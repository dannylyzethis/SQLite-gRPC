# Cargo.toml - Fixed for SQLx 0.8.6

[package]
name = “grpc-sqlite-server”
version = “0.1.0”
edition = “2021”

[dependencies]
tokio = { version = “1”, features = [“macros”, “rt-multi-thread”] }
tonic = “0.14”
prost = “0.14”
sqlx = { version = “0.8”, features = [“runtime-tokio-rustls”, “sqlite”] }  # Removed chrono
serde = { version = “1”, features = [“derive”] }
serde_json = “1”
tracing = “0.1”
tracing-subscriber = “0.3”
anyhow = “1”
base64 = “0.22”

[build-dependencies]
tonic-prost-build = “0.14”

-----

# src/db_manager.rs - Fixed for SQLx 0.8.6

use crate::database::{Value, ColumnSpec, WriteValueRequest};
use crate::value_converter::ValueConverter;
use anyhow::{Result, anyhow};
use sqlx::{SqlitePool, Row, Sqlite};
use std::collections::HashMap;
use tracing::{info, warn};

pub struct DatabaseManager {
pool: SqlitePool,
converter: ValueConverter,
}

impl DatabaseManager {
pub async fn new(database_url: &str) -> Result<Self> {
// SQLx 0.8.x way to create pool
let pool = SqlitePool::connect(database_url).await?;

```
    // Enable foreign keys and other pragmas
    sqlx::query("PRAGMA foreign_keys = ON")
        .execute(&pool)
        .await?;
        
    Ok(Self {
        pool,
        converter: ValueConverter::new(),
    })
}

pub async fn write_value(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    column_name: &str,
    column_value: &Option<Value>,
    create_if_missing: bool,
) -> Result<i64> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let column_value = column_value.as_ref().ok_or_else(|| anyhow!("Column value is required"))?;

    let id_sql_value = self.converter.value_to_string(id_value)?;
    let col_sql_value = self.converter.value_to_string(column_value)?;

    if create_if_missing {
        // Use UPSERT - works in SQLx 0.8.x
        let query = format!(
            "INSERT OR REPLACE INTO {} ({}, {}) VALUES (?, ?)",
            table_name, id_column, column_name
        );
        let result = sqlx::query(&query)
            .bind(&id_sql_value)
            .bind(&col_sql_value)
            .execute(&self.pool)
            .await?;
        Ok(result.rows_affected() as i64)
    } else {
        // Update existing row only
        let query = format!(
            "UPDATE {} SET {} = ? WHERE {} = ?",
            table_name, column_name, id_column
        );
        let result = sqlx::query(&query)
            .bind(&col_sql_value)
            .bind(&id_sql_value)
            .execute(&self.pool)
            .await?;
        Ok(result.rows_affected() as i64)
    }
}

pub async fn write_row(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    column_values: HashMap<String, Value>,
    create_if_missing: bool,
    upsert: bool,
) -> Result<(i64, Option<Value>)> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;

    if upsert || create_if_missing {
        // Insert or replace
        let mut columns = vec![id_column.to_string()];
        let mut values = vec![self.converter.value_to_string(id_value)?];
        
        for (col, val) in column_values {
            columns.push(col);
            values.push(self.converter.value_to_string(&val)?);
        }

        let placeholders = vec!["?"; columns.len()].join(", ");
        let columns_str = columns.join(", ");
        
        let query = format!(
            "INSERT OR REPLACE INTO {} ({}) VALUES ({})",
            table_name, columns_str, placeholders
        );

        let mut query_builder = sqlx::query(&query);
        for value in &values {
            query_builder = query_builder.bind(value);
        }

        let result = query_builder.execute(&self.pool).await?;
        Ok((result.rows_affected() as i64, None))
    } else {
        // Update existing row only
        if column_values.is_empty() {
            return Err(anyhow!("No column values provided for update"));
        }

        let set_clauses: Vec<String> = column_values.keys()
            .map(|col| format!("{} = ?", col))
            .collect();
        let set_clause = set_clauses.join(", ");

        let query = format!(
            "UPDATE {} SET {} WHERE {} = ?",
            table_name, set_clause, id_column
        );

        let mut query_builder = sqlx::query(&query);
        for val in column_values.values() {
            query_builder = query_builder.bind(self.converter.value_to_string(val)?);
        }
        query_builder = query_builder.bind(self.converter.value_to_string(id_value)?);

        let result = query_builder.execute(&self.pool).await?;
        Ok((result.rows_affected() as i64, None))
    }
}

pub async fn read_value(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    column_name: &str,
) -> Result<Option<Value>> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let id_sql_value = self.converter.value_to_string(id_value)?;

    let query = format!(
        "SELECT {} FROM {} WHERE {} = ?",
        column_name, table_name, id_column
    );

    let row = sqlx::query(&query)
        .bind(&id_sql_value)
        .fetch_optional(&self.pool)
        .await?;

    if let Some(row) = row {
        // SQLx 0.8.x way to get values
        let value: Option<String> = row.try_get(0).ok();
        if let Some(val) = value {
            Ok(Some(self.converter.string_to_value(&val)?))
        } else {
            Ok(None)
        }
    } else {
        Ok(None)
    }
}

pub async fn read_row(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    columns: Vec<String>,
) -> Result<Option<HashMap<String, Value>>> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let id_sql_value = self.converter.value_to_string(id_value)?;

    let columns_str = if columns.is_empty() {
        "*".to_string()
    } else {
        columns.join(", ")
    };

    let query = format!(
        "SELECT {} FROM {} WHERE {} = ?",
        columns_str, table_name, id_column
    );

    let row = sqlx::query(&query)
        .bind(&id_sql_value)
        .fetch_optional(&self.pool)
        .await?;

    if let Some(row) = row {
        let mut result = HashMap::new();
        
        // Get column names
        let column_names = if columns.is_empty() {
            // Get all column names from the row
            (0..row.len()).map(|i| row.column(i).name().to_string()).collect()
        } else {
            columns
        };

        for (i, col_name) in column_names.iter().enumerate() {
            if let Ok(value) = row.try_get::<Option<String>, _>(i) {
                if let Some(val) = value {
                    result.insert(col_name.clone(), self.converter.string_to_value(&val)?);
                }
            }
        }
        Ok(Some(result))
    } else {
        Ok(None)
    }
}

pub async fn read_table(
    &self,
    table_name: &str,
    columns: Vec<String>,
    where_clause: Option<String>,
    order_by: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<(Vec<HashMap<String, Value>>, i64)> {
    let columns_str = if columns.is_empty() {
        "*".to_string()
    } else {
        columns.join(", ")
    };

    let mut query = format!("SELECT {} FROM {}", columns_str, table_name);

    if let Some(where_clause) = where_clause {
        if !where_clause.is_empty() {
            query.push_str(&format!(" WHERE {}", where_clause));
        }
    }

    if let Some(order_by) = order_by {
        if !order_by.is_empty() {
            query.push_str(&format!(" ORDER BY {}", order_by));
        }
    }

    if let Some(limit) = limit {
        query.push_str(&format!(" LIMIT {}", limit));
        if let Some(offset) = offset {
            query.push_str(&format!(" OFFSET {}", offset));
        }
    }

    let rows = sqlx::query(&query).fetch_all(&self.pool).await?;

    let mut results = Vec::new();
    for row in &rows {
        let mut result = HashMap::new();
        for i in 0..row.len() {
            let col_name = row.column(i).name();
            if let Ok(value) = row.try_get::<Option<String>, _>(i) {
                if let Some(val) = value {
                    result.insert(col_name.to_string(), self.converter.string_to_value(&val)?);
                }
            }
        }
        results.push(result);
    }

    // Get total count
    let count_query = format!("SELECT COUNT(*) FROM {}", table_name);
    let count_row = sqlx::query(&count_query).fetch_one(&self.pool).await?;
    let total_count: i64 = count_row.try_get(0)?;

    Ok((results, total_count))
}

pub async fn create_table(
    &self,
    table_name: &str,
    columns: Vec<ColumnSpec>,
    if_not_exists: bool,
) -> Result<()> {
    let if_not_exists_clause = if if_not_exists { "IF NOT EXISTS" } else { "" };

    let column_defs: Vec<String> = columns.iter().map(|col| {
        let mut def = format!("{} {}", col.name, col.data_type.to_uppercase());
        
        if col.primary_key {
            def.push_str(" PRIMARY KEY");
        }
        if col.not_null {
            def.push_str(" NOT NULL");
        }
        if col.unique {
            def.push_str(" UNIQUE");
        }
        if !col.default_value.is_empty() {
            def.push_str(&format!(" DEFAULT {}", col.default_value));
        }
        
        def
    }).collect();

    let query = format!(
        "CREATE TABLE {} {} ({})",
        if_not_exists_clause,
        table_name,
        column_defs.join(", ")
    );

    sqlx::query(&query).execute(&self.pool).await?;
    Ok(())
}

pub async fn drop_table(&self, table_name: &str, if_exists: bool) -> Result<()> {
    let if_exists_clause = if if_exists { "IF EXISTS" } else { "" };
    let query = format!("DROP TABLE {} {}", if_exists_clause, table_name);
    sqlx::query(&query).execute(&self.pool).await?;
    Ok(())
}

pub async fn list_tables(&self) -> Result<Vec<String>> {
    let rows = sqlx::query("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        .fetch_all(&self.pool)
        .await?;

    let mut tables = Vec::new();
    for row in rows {
        let name: String = row.try_get("name")?;
        tables.push(name);
    }

    Ok(tables)
}
```

}

-----

# src/value_converter.rs - Simplified for SQLx 0.8.6

use crate::database::Value;
use anyhow::{Result, anyhow};

pub struct ValueConverter;

impl ValueConverter {
pub fn new() -> Self {
Self
}

```
// Convert protobuf Value to String (SQLite stores everything as text anyway)
pub fn value_to_string(&self, value: &Value) -> Result<String> {
    match &value.value_type {
        Some(value_type) => match value_type {
            crate::database::value::ValueType::TextValue(s) => Ok(s.clone()),
            crate::database::value::ValueType::IntValue(i) => Ok(i.to_string()),
            crate::database::value::ValueType::FloatValue(f) => Ok(f.to_string()),
            crate::database::value::ValueType::BoolValue(b) => Ok(b.to_string()),
            crate::database::value::ValueType::BlobValue(bytes) => Ok(base64::encode(bytes)),
        },
        None => Ok("NULL".to_string()),
    }
}

// Convert String back to protobuf Value
pub fn string_to_value(&self, s: &str) -> Result<Value> {
    // Try to detect the original type
    if s == "NULL" {
        return Ok(Value { value_type: None });
    }

    // Try parsing as different types
    if let Ok(i) = s.parse::<i64>() {
        return Ok(Value {
            value_type: Some(crate::database::value::ValueType::IntValue(i)),
        });
    }

    if let Ok(f) = s.parse::<f64>() {
        return Ok(Value {
            value_type: Some(crate::database::value::ValueType::FloatValue(f)),
        });
    }

    if let Ok(b) = s.parse::<bool>() {
        return Ok(Value {
            value_type: Some(crate::database::value::ValueType::BoolValue(b)),
        });
    }

    // Try base64 decode (for blobs)
    if let Ok(bytes) = base64::decode(s) {
        // Only treat as blob if it's valid base64 and contains non-printable chars
        if bytes.iter().any(|&b| b < 32 && b != 9 && b != 10 && b != 13) {
            return Ok(Value {
                value_type: Some(crate::database::value::ValueType::BlobValue(bytes)),
            });
        }
    }

    // Default to text
    Ok(Value {
        value_type: Some(crate::database::value::ValueType::TextValue(s.to_string())),
    })
}
```

}

-----

# Quick fix for your existing code:

# 1. Update Cargo.toml (remove chrono from sqlx features)

[dependencies]
sqlx = { version = “0.8”, features = [“runtime-tokio-rustls”, “sqlite”] }

# 2. Change connection creation:

# OLD (doesn’t work in 0.8.6):

let pool = SqlitePoolOptions::new().connect(database_url).await?;

# NEW (works in 0.8.6):

let pool = SqlitePool::connect(database_url).await?;

# 3. Change row value access:

# OLD:

let value = row.get::<String, _>(0);

# NEW:

let value: String = row.try_get(0)?;

# OR:

let value: Option<String> = row.try_get(0).ok();

# 4. Connection strings:

# Use: “sqlite://database.db”

# NOT: “sqlite:./database.db”

-----

# Test to see if it works:

cargo clean
cargo build
