# Fixed db_manager.rs - Column name access for SQLx 0.8.6

use crate::database::{Value, ColumnSpec, WriteValueRequest};
use crate::value_converter::ValueConverter;
use anyhow::{Result, anyhow};
use sqlx::{SqlitePool, Row, Column};
use std::collections::HashMap;
use tracing::{info, warn};

pub struct DatabaseManager {
pool: SqlitePool,
converter: ValueConverter,
}

impl DatabaseManager {
pub async fn new(database_url: &str) -> Result<Self> {
let pool = SqlitePool::connect(database_url).await?;

```
    // Enable foreign keys
    sqlx::query("PRAGMA foreign_keys = ON")
        .execute(&pool)
        .await?;
        
    Ok(Self {
        pool,
        converter: ValueConverter::new(),
    })
}

// ... (keep other methods the same) ...

pub async fn read_row(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    columns: Vec<String>,
) -> Result<Option<HashMap<String, Value>>> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let id_sql_value = self.converter.value_to_string(id_value)?;

    let columns_str = if columns.is_empty() {
        "*".to_string()
    } else {
        columns.join(", ")
    };

    let query = format!(
        "SELECT {} FROM {} WHERE {} = ?",
        columns_str, table_name, id_column
    );

    let row = sqlx::query(&query)
        .bind(&id_sql_value)
        .fetch_optional(&self.pool)
        .await?;

    if let Some(row) = row {
        let mut result = HashMap::new();
        
        // FIXED: SQLx 0.8.6 column name access
        for i in 0..row.len() {
            let col = row.column(i);
            let col_name = col.name().to_string();  // Try this first
            
            if let Ok(value) = row.try_get::<Option<String>, _>(i) {
                if let Some(val) = value {
                    result.insert(col_name, self.converter.string_to_value(&val)?);
                }
            }
        }
        Ok(Some(result))
    } else {
        Ok(None)
    }
}

pub async fn read_table(
    &self,
    table_name: &str,
    columns: Vec<String>,
    where_clause: Option<String>,
    order_by: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<(Vec<HashMap<String, Value>>, i64)> {
    let columns_str = if columns.is_empty() {
        "*".to_string()
    } else {
        columns.join(", ")
    };

    let mut query = format!("SELECT {} FROM {}", columns_str, table_name);

    if let Some(where_clause) = where_clause {
        if !where_clause.is_empty() {
            query.push_str(&format!(" WHERE {}", where_clause));
        }
    }

    if let Some(order_by) = order_by {
        if !order_by.is_empty() {
            query.push_str(&format!(" ORDER BY {}", order_by));
        }
    }

    if let Some(limit) = limit {
        query.push_str(&format!(" LIMIT {}", limit));
        if let Some(offset) = offset {
            query.push_str(&format!(" OFFSET {}", offset));
        }
    }

    let rows = sqlx::query(&query).fetch_all(&self.pool).await?;

    let mut results = Vec::new();
    for row in &rows {
        let mut result = HashMap::new();
        
        // FIXED: SQLx 0.8.6 column iteration
        for i in 0..row.len() {
            let col = row.column(i);
            let col_name = col.name().to_string();  // SQLx 0.8.6 way
            
            if let Ok(value) = row.try_get::<Option<String>, _>(i) {
                if let Some(val) = value {
                    result.insert(col_name, self.converter.string_to_value(&val)?);
                }
            }
        }
        results.push(result);
    }

    // Get total count
    let count_query = format!("SELECT COUNT(*) FROM {}", table_name);
    let count_row = sqlx::query(&count_query).fetch_one(&self.pool).await?;
    let total_count: i64 = count_row.try_get(0)?;

    Ok((results, total_count))
}

// ... (keep other methods the same) ...
```

}

-----

# Alternative fix if .name() still doesn’t work:

# Try these different approaches in order:

# Option 1: Direct name access

let col_name = col.name().to_string();

# Option 2: If name() returns &str directly

let col_name = col.name();

# Option 3: Use ordinal with predefined names

let col_name = format!(“column_{}”, i);

# Option 4: Get column info differently

let col_name = match row.column(i).name() {
name => name.to_string(),
};

-----

# Quick test to see what works:

# Add this debug code to see the actual API:

pub async fn debug_columns(&self) -> Result<()> {
let query = “SELECT ‘test’ as name, 123 as id”;
let row = sqlx::query(query).fetch_one(&self.pool).await?;

```
for i in 0..row.len() {
    let col = row.column(i);
    println!("Column {}: {:?}", i, col);
    
    // Try different methods:
    // println!("Name: {}", col.name());
    // println!("Type: {:?}", col.type_info());
}

Ok(())
```

}

-----

# Complete working example without column names:

# If all else fails, use this simpler approach:

pub async fn read_row_simple(
&self,
table_name: &str,
id_column: &str,
id_value: &Option<Value>,
columns: Vec<String>,
) -> Result<Option<HashMap<String, Value>>> {
let id_value = id_value.as_ref().ok_or_else(|| anyhow!(“ID value is required”))?;
let id_sql_value = self.converter.value_to_string(id_value)?;

```
// If no specific columns requested, just return a simple map with indices
if columns.is_empty() {
    let query = format!("SELECT * FROM {} WHERE {} = ?", table_name, id_column);
    let row = sqlx::query(&query)
        .bind(&id_sql_value)
        .fetch_optional(&self.pool)
        .await?;

    if let Some(row) = row {
        let mut result = HashMap::new();
        for i in 0..row.len() {
            let key = format!("column_{}", i);
            if let Ok(Some(value)) = row.try_get::<Option<String>, _>(i) {
                result.insert(key, self.converter.string_to_value(&value)?);
            }
        }
        Ok(Some(result))
    } else {
        Ok(None)
    }
} else {
    // Use the provided column names
    let columns_str = columns.join(", ");
    let query = format!("SELECT {} FROM {} WHERE {} = ?", columns_str, table_name, id_column);
    let row = sqlx::query(&query)
        .bind(&id_sql_value)
        .fetch_optional(&self.pool)
        .await?;

    if let Some(row) = row {
        let mut result = HashMap::new();
        for (i, col_name) in columns.iter().enumerate() {
            if let Ok(Some(value)) = row.try_get::<Option<String>, _>(i) {
                result.insert(col_name.clone(), self.converter.string_to_value(&value)?);
            }
        }
        Ok(Some(result))
    } else {
        Ok(None)
    }
}
```

}
