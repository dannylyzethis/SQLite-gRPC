# database.proto

# Generic database operations proto file

syntax = “proto3”;

package database;

service DatabaseService {
// Write operations
rpc WriteValue(WriteValueRequest) returns (WriteValueResponse);
rpc WriteRow(WriteRowRequest) returns (WriteRowResponse);
rpc WriteMultipleValues(WriteMultipleValuesRequest) returns (WriteMultipleValuesResponse);

```
// Read operations  
rpc ReadValue(ReadValueRequest) returns (ReadValueResponse);
rpc ReadRow(ReadRowRequest) returns (ReadRowResponse);
rpc ReadTable(ReadTableRequest) returns (ReadTableResponse);
rpc ReadQuery(ReadQueryRequest) returns (ReadQueryResponse);

// Table management
rpc CreateTable(CreateTableRequest) returns (CreateTableResponse);
rpc DropTable(DropTableRequest) returns (DropTableResponse);
rpc ListTables(ListTablesRequest) returns (ListTablesResponse);
```

}

// Data types
message Value {
oneof value_type {
string text_value = 1;
int64 int_value = 2;
double float_value = 3;
bool bool_value = 4;
bytes blob_value = 5;
}
}

message ColumnSpec {
string name = 1;
string data_type = 2; // TEXT, INTEGER, REAL, BLOB, BOOLEAN
bool not_null = 3;
bool primary_key = 4;
bool unique = 5;
string default_value = 6;
}

// Write operations
message WriteValueRequest {
string table_name = 1;
string id_column = 2;
Value id_value = 3;
string column_name = 4;
Value column_value = 5;
bool create_if_missing = 6; // Create row if ID doesn’t exist
}

message WriteValueResponse {
bool success = 1;
string message = 2;
int64 rows_affected = 3;
}

message WriteRowRequest {
string table_name = 1;
string id_column = 2;
Value id_value = 3;
map<string, Value> column_values = 4;
bool create_if_missing = 5;
bool upsert = 6; // Insert or update
}

message WriteRowResponse {
bool success = 1;
string message = 2;
int64 rows_affected = 3;
Value generated_id = 4; // If using auto-increment
}

message WriteMultipleValuesRequest {
repeated WriteValueRequest writes = 1;
bool atomic = 2; // All or nothing transaction
}

message WriteMultipleValuesResponse {
bool success = 1;
string message = 2;
int64 total_rows_affected = 3;
repeated string individual_results = 4;
}

// Read operations
message ReadValueRequest {
string table_name = 1;
string id_column = 2;
Value id_value = 3;
string column_name = 4;
}

message ReadValueResponse {
bool found = 1;
Value value = 2;
string message = 3;
}

message ReadRowRequest {
string table_name = 1;
string id_column = 2;
Value id_value = 3;
repeated string columns = 4; // Empty means all columns
}

message ReadRowResponse {
bool found = 1;
map<string, Value> column_values = 2;
string message = 3;
}

message ReadTableRequest {
string table_name = 1;
repeated string columns = 2; // Empty means all columns
string where_clause = 3; // Optional WHERE condition
string order_by = 4; // Optional ORDER BY
int32 limit = 5; // Optional LIMIT
int32 offset = 6; // Optional OFFSET
}

message ReadTableResponse {
bool success = 1;
repeated map<string, Value> rows = 2;
int64 total_count = 3;
string message = 4;
}

message ReadQueryRequest {
string sql_query = 1;
repeated Value parameters = 2; // For prepared statements
}

message ReadQueryResponse {
bool success = 1;
repeated map<string, Value> rows = 2;
repeated string column_names = 3;
string message = 4;
}

// Table management
message CreateTableRequest {
string table_name = 1;
repeated ColumnSpec columns = 2;
bool if_not_exists = 3;
}

message CreateTableResponse {
bool success = 1;
string message = 2;
}

message DropTableRequest {
string table_name = 1;
bool if_exists = 2;
}

message DropTableResponse {
bool success = 1;
string message = 2;
}

message ListTablesRequest {
}

message ListTablesResponse {
repeated string table_names = 1;
string message = 2;
}

-----

# Cargo.toml

[package]
name = “grpc-sqlite-server”
version = “0.1.0”
edition = “2021”

[dependencies]
tokio = { version = “1.0”, features = [“macros”, “rt-multi-thread”] }
tonic = “0.10”
prost = “0.12”
sqlx = { version = “0.7”, features = [“runtime-tokio-rustls”, “sqlite”, “chrono”] }
serde = { version = “1.0”, features = [“derive”] }
serde_json = “1.0”
tracing = “0.1”
tracing-subscriber = “0.3”
anyhow = “1.0”
thiserror = “1.0”

[build-dependencies]
tonic-build = “0.10”

-----

# build.rs

fn main() -> Result<(), Box<dyn std::error::Error>> {
tonic_build::compile_protos(“database.proto”)?;
Ok(())
}

-----

# src/main.rs

use anyhow::Result;
use sqlx::sqlite::{SqlitePool, SqlitePoolOptions};
use std::collections::HashMap;
use tonic::{transport::Server, Request, Response, Status};
use tracing::{info, warn, error};

pub mod database {
tonic::include_proto!(“database”);
}

use database::{
database_service_server::{DatabaseService, DatabaseServiceServer},
*,
};

mod db_manager;
mod value_converter;

use db_manager::DatabaseManager;
use value_converter::ValueConverter;

#[derive(Debug)]
pub struct DatabaseServiceImpl {
db_manager: DatabaseManager,
}

impl DatabaseServiceImpl {
pub async fn new(database_url: &str) -> Result<Self> {
let pool = SqlitePoolOptions::new()
.max_connections(10)
.connect(database_url)
.await?;

```
    let db_manager = DatabaseManager::new(pool);
    
    Ok(Self { db_manager })
}
```

}

#[tonic::async_trait]
impl DatabaseService for DatabaseServiceImpl {
async fn write_value(
&self,
request: Request<WriteValueRequest>,
) -> Result<Response<WriteValueResponse>, Status> {
let req = request.into_inner();
info!(
“Writing value to table: {}, id_column: {}, column: {}”,
req.table_name, req.id_column, req.column_name
);

```
    match self.db_manager.write_value(
        &req.table_name,
        &req.id_column,
        &req.id_value,
        &req.column_name,
        &req.column_value,
        req.create_if_missing,
    ).await {
        Ok(rows_affected) => Ok(Response::new(WriteValueResponse {
            success: true,
            message: format!("Successfully updated {} row(s)", rows_affected),
            rows_affected,
        })),
        Err(e) => {
            error!("Failed to write value: {}", e);
            Ok(Response::new(WriteValueResponse {
                success: false,
                message: format!("Failed to write value: {}", e),
                rows_affected: 0,
            }))
        }
    }
}

async fn write_row(
    &self,
    request: Request<WriteRowRequest>,
) -> Result<Response<WriteRowResponse>, Status> {
    let req = request.into_inner();
    info!("Writing row to table: {}", req.table_name);

    match self.db_manager.write_row(
        &req.table_name,
        &req.id_column,
        &req.id_value,
        req.column_values,
        req.create_if_missing,
        req.upsert,
    ).await {
        Ok((rows_affected, generated_id)) => Ok(Response::new(WriteRowResponse {
            success: true,
            message: format!("Successfully affected {} row(s)", rows_affected),
            rows_affected,
            generated_id,
        })),
        Err(e) => {
            error!("Failed to write row: {}", e);
            Ok(Response::new(WriteRowResponse {
                success: false,
                message: format!("Failed to write row: {}", e),
                rows_affected: 0,
                generated_id: None,
            }))
        }
    }
}

async fn write_multiple_values(
    &self,
    request: Request<WriteMultipleValuesRequest>,
) -> Result<Response<WriteMultipleValuesResponse>, Status> {
    let req = request.into_inner();
    info!("Writing multiple values, atomic: {}", req.atomic);

    match self.db_manager.write_multiple_values(req.writes, req.atomic).await {
        Ok((total_affected, results)) => Ok(Response::new(WriteMultipleValuesResponse {
            success: true,
            message: format!("Successfully affected {} total row(s)", total_affected),
            total_rows_affected: total_affected,
            individual_results: results,
        })),
        Err(e) => {
            error!("Failed to write multiple values: {}", e);
            Ok(Response::new(WriteMultipleValuesResponse {
                success: false,
                message: format!("Failed to write multiple values: {}", e),
                total_rows_affected: 0,
                individual_results: vec![],
            }))
        }
    }
}

async fn read_value(
    &self,
    request: Request<ReadValueRequest>,
) -> Result<Response<ReadValueResponse>, Status> {
    let req = request.into_inner();
    info!(
        "Reading value from table: {}, id_column: {}, column: {}",
        req.table_name, req.id_column, req.column_name
    );

    match self.db_manager.read_value(
        &req.table_name,
        &req.id_column,
        &req.id_value,
        &req.column_name,
    ).await {
        Ok(Some(value)) => Ok(Response::new(ReadValueResponse {
            found: true,
            value: Some(value),
            message: "Value found".to_string(),
        })),
        Ok(None) => Ok(Response::new(ReadValueResponse {
            found: false,
            value: None,
            message: "Value not found".to_string(),
        })),
        Err(e) => {
            error!("Failed to read value: {}", e);
            Ok(Response::new(ReadValueResponse {
                found: false,
                value: None,
                message: format!("Failed to read value: {}", e),
            }))
        }
    }
}

async fn read_row(
    &self,
    request: Request<ReadRowRequest>,
) -> Result<Response<ReadRowResponse>, Status> {
    let req = request.into_inner();
    info!("Reading row from table: {}", req.table_name);

    match self.db_manager.read_row(
        &req.table_name,
        &req.id_column,
        &req.id_value,
        req.columns,
    ).await {
        Ok(Some(row)) => Ok(Response::new(ReadRowResponse {
            found: true,
            column_values: row,
            message: "Row found".to_string(),
        })),
        Ok(None) => Ok(Response::new(ReadRowResponse {
            found: false,
            column_values: HashMap::new(),
            message: "Row not found".to_string(),
        })),
        Err(e) => {
            error!("Failed to read row: {}", e);
            Ok(Response::new(ReadRowResponse {
                found: false,
                column_values: HashMap::new(),
                message: format!("Failed to read row: {}", e),
            }))
        }
    }
}

async fn read_table(
    &self,
    request: Request<ReadTableRequest>,
) -> Result<Response<ReadTableResponse>, Status> {
    let req = request.into_inner();
    info!("Reading table: {}", req.table_name);

    match self.db_manager.read_table(
        &req.table_name,
        req.columns,
        req.where_clause,
        req.order_by,
        req.limit,
        req.offset,
    ).await {
        Ok((rows, total_count)) => Ok(Response::new(ReadTableResponse {
            success: true,
            rows,
            total_count,
            message: format!("Retrieved {} rows", rows.len()),
        })),
        Err(e) => {
            error!("Failed to read table: {}", e);
            Ok(Response::new(ReadTableResponse {
                success: false,
                rows: vec![],
                total_count: 0,
                message: format!("Failed to read table: {}", e),
            }))
        }
    }
}

async fn read_query(
    &self,
    request: Request<ReadQueryRequest>,
) -> Result<Response<ReadQueryResponse>, Status> {
    let req = request.into_inner();
    info!("Executing custom query");

    match self.db_manager.read_query(&req.sql_query, req.parameters).await {
        Ok((rows, columns)) => Ok(Response::new(ReadQueryResponse {
            success: true,
            rows,
            column_names: columns,
            message: format!("Query executed successfully, {} rows returned", rows.len()),
        })),
        Err(e) => {
            error!("Failed to execute query: {}", e);
            Ok(Response::new(ReadQueryResponse {
                success: false,
                rows: vec![],
                column_names: vec![],
                message: format!("Failed to execute query: {}", e),
            }))
        }
    }
}

async fn create_table(
    &self,
    request: Request<CreateTableRequest>,
) -> Result<Response<CreateTableResponse>, Status> {
    let req = request.into_inner();
    info!("Creating table: {}", req.table_name);

    match self.db_manager.create_table(
        &req.table_name,
        req.columns,
        req.if_not_exists,
    ).await {
        Ok(_) => Ok(Response::new(CreateTableResponse {
            success: true,
            message: format!("Table '{}' created successfully", req.table_name),
        })),
        Err(e) => {
            error!("Failed to create table: {}", e);
            Ok(Response::new(CreateTableResponse {
                success: false,
                message: format!("Failed to create table: {}", e),
            }))
        }
    }
}

async fn drop_table(
    &self,
    request: Request<DropTableRequest>,
) -> Result<Response<DropTableResponse>, Status> {
    let req = request.into_inner();
    info!("Dropping table: {}", req.table_name);

    match self.db_manager.drop_table(&req.table_name, req.if_exists).await {
        Ok(_) => Ok(Response::new(DropTableResponse {
            success: true,
            message: format!("Table '{}' dropped successfully", req.table_name),
        })),
        Err(e) => {
            error!("Failed to drop table: {}", e);
            Ok(Response::new(DropTableResponse {
                success: false,
                message: format!("Failed to drop table: {}", e),
            }))
        }
    }
}

async fn list_tables(
    &self,
    _request: Request<ListTablesRequest>,
) -> Result<Response<ListTablesResponse>, Status> {
    info!("Listing tables");

    match self.db_manager.list_tables().await {
        Ok(tables) => Ok(Response::new(ListTablesResponse {
            table_names: tables,
            message: "Tables retrieved successfully".to_string(),
        })),
        Err(e) => {
            error!("Failed to list tables: {}", e);
            Ok(Response::new(ListTablesResponse {
                table_names: vec![],
                message: format!("Failed to list tables: {}", e),
            }))
        }
    }
}
```

}

#[tokio::main]
async fn main() -> Result<()> {
tracing_subscriber::init();

```
let database_url = "sqlite:./database.db";
let service = DatabaseServiceImpl::new(database_url).await?;

let addr = "[::1]:50051".parse()?;
info!("Starting gRPC server on {}", addr);

Server::builder()
    .add_service(DatabaseServiceServer::new(service))
    .serve(addr)
    .await?;

Ok(())
```

}

-----

# src/db_manager.rs

use crate::database::{Value, ColumnSpec, WriteValueRequest};
use crate::value_converter::ValueConverter;
use anyhow::{Result, anyhow};
use sqlx::{SqlitePool, Row};
use std::collections::HashMap;
use tracing::{info, warn};

pub struct DatabaseManager {
pool: SqlitePool,
converter: ValueConverter,
}

impl DatabaseManager {
pub fn new(pool: SqlitePool) -> Self {
Self {
pool,
converter: ValueConverter::new(),
}
}

```
pub async fn write_value(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    column_name: &str,
    column_value: &Option<Value>,
    create_if_missing: bool,
) -> Result<i64> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let column_value = column_value.as_ref().ok_or_else(|| anyhow!("Column value is required"))?;

    let id_sql_value = self.converter.value_to_sql(id_value)?;
    let col_sql_value = self.converter.value_to_sql(column_value)?;

    if create_if_missing {
        // Use UPSERT (INSERT OR REPLACE)
        let query = format!(
            "INSERT OR REPLACE INTO {} ({}, {}) VALUES (?, ?)",
            table_name, id_column, column_name
        );
        let result = sqlx::query(&query)
            .bind(id_sql_value)
            .bind(col_sql_value)
            .execute(&self.pool)
            .await?;
        Ok(result.rows_affected() as i64)
    } else {
        // Update existing row only
        let query = format!(
            "UPDATE {} SET {} = ? WHERE {} = ?",
            table_name, column_name, id_column
        );
        let result = sqlx::query(&query)
            .bind(col_sql_value)
            .bind(id_sql_value)
            .execute(&self.pool)
            .await?;
        Ok(result.rows_affected() as i64)
    }
}

pub async fn write_row(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    column_values: HashMap<String, Value>,
    create_if_missing: bool,
    upsert: bool,
) -> Result<(i64, Option<Value>)> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;

    if upsert || create_if_missing {
        // Insert or replace
        let mut columns = vec![id_column.to_string()];
        let mut values = vec![self.converter.value_to_sql(id_value)?];
        
        for (col, val) in column_values {
            columns.push(col);
            values.push(self.converter.value_to_sql(&val)?);
        }

        let placeholders = vec!["?"; columns.len()].join(", ");
        let columns_str = columns.join(", ");
        
        let query = format!(
            "INSERT OR REPLACE INTO {} ({}) VALUES ({})",
            table_name, columns_str, placeholders
        );

        let mut query_builder = sqlx::query(&query);
        for value in values {
            query_builder = query_builder.bind(value);
        }

        let result = query_builder.execute(&self.pool).await?;
        Ok((result.rows_affected() as i64, None))
    } else {
        // Update existing row only
        if column_values.is_empty() {
            return Err(anyhow!("No column values provided for update"));
        }

        let set_clauses: Vec<String> = column_values.keys()
            .map(|col| format!("{} = ?", col))
            .collect();
        let set_clause = set_clauses.join(", ");

        let query = format!(
            "UPDATE {} SET {} WHERE {} = ?",
            table_name, set_clause, id_column
        );

        let mut query_builder = sqlx::query(&query);
        for val in column_values.values() {
            query_builder = query_builder.bind(self.converter.value_to_sql(val)?);
        }
        query_builder = query_builder.bind(self.converter.value_to_sql(id_value)?);

        let result = query_builder.execute(&self.pool).await?;
        Ok((result.rows_affected() as i64, None))
    }
}

pub async fn write_multiple_values(
    &self,
    writes: Vec<WriteValueRequest>,
    atomic: bool,
) -> Result<(i64, Vec<String>)> {
    if atomic {
        // Use transaction
        let mut tx = self.pool.begin().await?;
        let mut total_affected = 0i64;
        let mut results = Vec::new();

        for write in writes {
            match self.write_value_with_tx(
                &mut tx,
                &write.table_name,
                &write.id_column,
                &write.id_value,
                &write.column_name,
                &write.column_value,
                write.create_if_missing,
            ).await {
                Ok(affected) => {
                    total_affected += affected;
                    results.push(format!("Success: {} rows affected", affected));
                }
                Err(e) => {
                    tx.rollback().await?;
                    return Err(e);
                }
            }
        }

        tx.commit().await?;
        Ok((total_affected, results))
    } else {
        // Execute individually
        let mut total_affected = 0i64;
        let mut results = Vec::new();

        for write in writes {
            match self.write_value(
                &write.table_name,
                &write.id_column,
                &write.id_value,
                &write.column_name,
                &write.column_value,
                write.create_if_missing,
            ).await {
                Ok(affected) => {
                    total_affected += affected;
                    results.push(format!("Success: {} rows affected", affected));
                }
                Err(e) => {
                    results.push(format!("Error: {}", e));
                }
            }
        }

        Ok((total_affected, results))
    }
}

async fn write_value_with_tx(
    &self,
    tx: &mut sqlx::Transaction<'_, sqlx::Sqlite>,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    column_name: &str,
    column_value: &Option<Value>,
    create_if_missing: bool,
) -> Result<i64> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let column_value = column_value.as_ref().ok_or_else(|| anyhow!("Column value is required"))?;

    let id_sql_value = self.converter.value_to_sql(id_value)?;
    let col_sql_value = self.converter.value_to_sql(column_value)?;

    if create_if_missing {
        let query = format!(
            "INSERT OR REPLACE INTO {} ({}, {}) VALUES (?, ?)",
            table_name, id_column, column_name
        );
        let result = sqlx::query(&query)
            .bind(id_sql_value)
            .bind(col_sql_value)
            .execute(&mut **tx)
            .await?;
        Ok(result.rows_affected() as i64)
    } else {
        let query = format!(
            "UPDATE {} SET {} = ? WHERE {} = ?",
            table_name, column_name, id_column
        );
        let result = sqlx::query(&query)
            .bind(col_sql_value)
            .bind(id_sql_value)
            .execute(&mut **tx)
            .await?;
        Ok(result.rows_affected() as i64)
    }
}

pub async fn read_value(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    column_name: &str,
) -> Result<Option<Value>> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let id_sql_value = self.converter.value_to_sql(id_value)?;

    let query = format!(
        "SELECT {} FROM {} WHERE {} = ?",
        column_name, table_name, id_column
    );

    let row = sqlx::query(&query)
        .bind(id_sql_value)
        .fetch_optional(&self.pool)
        .await?;

    if let Some(row) = row {
        let sql_value = row.try_get::<sqlx::types::Json<serde_json::Value>, _>(0)?;
        Ok(Some(self.converter.sql_to_value(&sql_value.0)?))
    } else {
        Ok(None)
    }
}

pub async fn read_row(
    &self,
    table_name: &str,
    id_column: &str,
    id_value: &Option<Value>,
    columns: Vec<String>,
) -> Result<Option<HashMap<String, Value>>> {
    let id_value = id_value.as_ref().ok_or_else(|| anyhow!("ID value is required"))?;
    let id_sql_value = self.converter.value_to_sql(id_value)?;

    let columns_str = if columns.is_empty() {
        "*".to_string()
    } else {
        columns.join(", ")
    };

    let query = format!(
        "SELECT {} FROM {} WHERE {} = ?",
        columns_str, table_name, id_column
    );

    let row = sqlx::query(&query)
        .bind(id_sql_value)
        .fetch_optional(&self.pool)
        .await?;

    if let Some(row) = row {
        let mut result = HashMap::new();
        let column_names = if columns.is_empty() {
            // Get all column names from the row
            (0..row.len()).map(|i| row.column(i).name().to_string()).collect()
        } else {
            columns
        };

        for (i, col_name) in column_names.iter().enumerate() {
            if let Ok(sql_value) = row.try_get::<sqlx::types::Json<serde_json::Value>, _>(i) {
                result.insert(col_name.clone(), self.converter.sql_to_value(&sql_value.0)?);
            }
        }
        Ok(Some(result))
    } else {
        Ok(None)
    }
}

pub async fn read_table(
    &self,
    table_name: &str,
    columns: Vec<String>,
    where_clause: Option<String>,
    order_by: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<(Vec<HashMap<String, Value>>, i64)> {
    let columns_str = if columns.is_empty() {
        "*".to_string()
    } else {
        columns.join(", ")
    };

    let mut query = format!("SELECT {} FROM {}", columns_str, table_name);

    if let Some(where_clause) = where_clause {
        if !where_clause.is_empty() {
            query.push_str(&format!(" WHERE {}", where_clause));
        }
    }

    if let Some(order_by) = order_by {
        if !order_by.is_empty() {
            query.push_str(&format!(" ORDER BY {}", order_by));
        }
    }

    if let Some(limit) = limit {
        query.push_str(&format!(" LIMIT {}", limit));
        if let Some(offset) = offset {
            query.push_str(&format!(" OFFSET {}", offset));
        }
    }

    let rows = sqlx::query(&query).fetch_all(&self.pool).await?;

    let mut results = Vec::new();
    for row in rows {
        let mut result = HashMap::new();
        for i in 0..row.len() {
            let col_name = row.column(i).name();
            if let Ok(sql_value) = row.try_get::<sqlx::types::Json<serde_json::Value>, _>(i) {
                result.insert(col_name.to_string(), self.converter.sql_to_value(&sql_value.0)?);
            }
        }
        results.push(result);
    }

    // Get total count
    let count_query = format!("SELECT COUNT(*) FROM {}", table_name);
    let count_row = sqlx::query(&count_query).fetch_one(&self.pool).await?;
    let total_count = count_row.get::<i64, _>(0);

    Ok((results, total_count))
}

pub async fn read_query(
    &self,
    sql_query: &str,
    parameters: Vec<Value>,
) -> Result<(Vec<HashMap<String, Value>>, Vec<String>)> {
    let mut query_builder = sqlx::query(sql_query);

    for param in parameters {
        query_builder = query_builder.bind(self.converter.value_to_sql(&param)?);
    }

    let rows = query_builder.fetch_all(&self.pool).await?;

    let mut results = Vec::new();
    let mut column_names = Vec::new();

    if let Some(first_row) = rows.first() {
        column_names = (0..first_row.len())
            .map(|i| first_row.column(i).name().to_string())
            .collect();
    }

    for row in rows {
        let mut result = HashMap::new();
        for i in 0..row.len() {
            let col_name = row.column(i).name();
            if let Ok(sql_value) = row.try_get::<sqlx::types::Json<serde_json::Value>, _>(i) {
                result.insert(col_name.to_string(), self.converter.sql_to_value(&sql_value.0)?);
            }
        }
        results.push(result);
    }

    Ok((results, column_names))
}

pub async fn create_table(
    &self,
    table_name: &str,
    columns: Vec<ColumnSpec>,
    if_not_exists: bool,
) -> Result<()> {
    let if_not_exists_clause = if if_not_exists { "IF NOT EXISTS" } else { "" };

    let column_defs: Vec<String> = columns.iter().map(|col| {
        let mut def = format!("{} {}", col.name, col.data_type.to_uppercase());
        
        if col.primary_key {
            def.push_str(" PRIMARY KEY");
        }
        if col.not_null {
            def.push_str(" NOT NULL");
        }
        if col.unique {
            def.push_str(" UNIQUE");
        }
        if !col.default_value.is_empty() {
            def.push_str(&format!(" DEFAULT {}", col.default_value));
        }
        
        def
    }).collect();

    let query = format!(
        "CREATE TABLE {} {} ({})",
        if_not_exists_clause,
        table_name,
        column_defs.join(", ")
    );

    sqlx::query(&query).execute(&self.pool).await?;
    Ok(())
}

pub async fn drop_table(&self, table_name: &str, if_exists: bool) -> Result<()> {
    let if_exists_clause = if if_exists { "IF EXISTS" } else { "" };
    let query = format!("DROP TABLE {} {}", if_exists_clause, table_name);
    sqlx::query(&query).execute(&self.pool).await?;
    Ok(())
}

pub async fn list_tables(&self) -> Result<Vec<String>> {
    let rows = sqlx::query("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        .fetch_all(&self.pool)
        .await?;

    let tables = rows.iter()
        .map(|row| row.get::<String, _>("name"))
        .collect();

    Ok(tables)
}
```

}

-----

# src/value_converter.rs

use crate::database::Value;
use anyhow::{Result, anyhow};
use serde_json;

pub struct ValueConverter;

impl ValueConverter {
pub fn new() -> Self {
Self
}

```
pub fn value_to_sql(&self, value: &Value) -> Result<serde_json::Value> {
    match &value.value_type {
        Some(value_type) => match value_type {
            crate::database::value::ValueType::TextValue(s) => Ok(serde_json::Value::String(s.clone())),
            crate::database::value::ValueType::IntValue(i) => Ok(serde_json::Value::Number(serde_json::Number::from(*i))),
            crate::database::value::ValueType::FloatValue(f) => {
                Ok(serde_json::Value::Number(
                    serde_json::Number::from_f64(*f).ok_or_else(|| anyhow!("Invalid float value"))?
                ))
            },
            crate::database::value::ValueType::BoolValue(b) => Ok(serde_json::Value::Bool(*b)),
            crate::database::value::ValueType::BlobValue(bytes) => {
                Ok(serde_json::Value::String(base64::encode(bytes)))
            },
        },
        None => Ok(serde_json::Value::Null),
    }
}

pub fn sql_to_value(&self, json_value: &serde_json::Value) -> Result<Value> {
    let value_type = match json_value {
        serde_json::Value::Null => None,
        serde_json::Value::String(s) => {
            // Try to detect if this is base64 encoded binary data
            if let Ok(bytes) = base64::decode(s) {
                Some(crate::database::value::ValueType::BlobValue(bytes))
            } else {
                Some(crate::database::value::ValueType::TextValue(s.clone()))
            }
        },
        serde_json::Value::Number(n) => {
            if let Some(i) = n.as_i64() {
                Some(crate::database::value::ValueType::IntValue(i))
            } else if let Some(f) = n.as_f64() {
                Some(crate::database::value::ValueType::FloatValue(f))
            } else {
                return Err(anyhow!("Invalid number format"));
            }
        },
        serde_json::Value::Bool(b) => Some(crate::database::value::ValueType::BoolValue(*b)),
        _ => return Err(anyhow!("Unsupported JSON value type")),
    };

    Ok(Value { value_type })
}
```

}

-----

# client_example.rs

# Example client for testing the server

use tonic::Request;
use std::collections::HashMap;

pub mod database {
tonic::include_proto!(“database”);
}

use database::{
database_service_client::DatabaseServiceClient,
*,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
let mut client = DatabaseServiceClient::connect(“http://[::1]:50051”).await?;

```
// Create a test table
println!("Creating table...");
let response = client.create_table(Request::new(CreateTableRequest {
    table_name: "users".to_string(),
    columns: vec![
        ColumnSpec {
            name: "id".to_string(),
            data_type: "INTEGER".to_string(),
            primary_key: true,
            not_null: true,
            unique: false,
            default_value: "".to_string(),
        },
        ColumnSpec {
            name: "name".to_string(),
            data_type: "TEXT".to_string(),
            primary_key: false,
            not_null: true,
            unique: false,
            default_value: "".to_string(),
        },
        ColumnSpec {
            name: "email".to_string(),
            data_type: "TEXT".to_string(),
            primary_key: false,
            not_null: true,
            unique: true,
            default_value: "".to_string(),
        },
    ],
    if_not_exists: true,
})).await?;
println!("Create table response: {:?}", response.into_inner());

// Write a complete row
println!("\nWriting row...");
let mut column_values = HashMap::new();
column_values.insert("name".to_string(), Value {
    value_type: Some(database::value::ValueType::TextValue("John Doe".to_string())),
});
column_values.insert("email".to_string(), Value {
    value_type: Some(database::value::ValueType::TextValue("john@example.com".to_string())),
});

let response = client.write_row(Request::new(WriteRowRequest {
    table_name: "users".to_string(),
    id_column: "id".to_string(),
    id_value: Some(Value {
        value_type: Some(database::value::ValueType::IntValue(1)),
    }),
    column_values,
    create_if_missing: true,
    upsert: true,
})).await?;
println!("Write row response: {:?}", response.into_inner());

// Write a single value
println!("\nWriting single value...");
let response = client.write_value(Request::new(WriteValueRequest {
    table_name: "users".to_string(),
    id_column: "id".to_string(),
    id_value: Some(Value {
        value_type: Some(database::value::ValueType::IntValue(1)),
    }),
    column_name: "name".to_string(),
    column_value: Some(Value {
        value_type: Some(database::value::ValueType::TextValue("Jane Smith".to_string())),
    }),
    create_if_missing: false,
})).await?;
println!("Write value response: {:?}", response.into_inner());

// Read the value back
println!("\nReading value...");
let response = client.read_value(Request::new(ReadValueRequest {
    table_name: "users".to_string(),
    id_column: "id".to_string(),
    id_value: Some(Value {
        value_type: Some(database::value::ValueType::IntValue(1)),
    }),
    column_name: "name".to_string(),
})).await?;
println!("Read value response: {:?}", response.into_inner());

// Read entire row
println!("\nReading row...");
let response = client.read_row(Request::new(ReadRowRequest {
    table_name: "users".to_string(),
    id_column: "id".to_string(),
    id_value: Some(Value {
        value_type: Some(database::value::ValueType::IntValue(1)),
    }),
    columns: vec![], // Empty means all columns
})).await?;
println!("Read row response: {:?}", response.into_inner());

// List all tables
println!("\nListing tables...");
let response = client.list_tables(Request::new(ListTablesRequest {})).await?;
println!("List tables response: {:?}", response.into_inner());

Ok(())
```

}

-----

# README.md

# Generic gRPC SQLite Server

A Rust-based gRPC server that provides generic database operations for SQLite.

## Features

- **Generic Operations**: Write/read by table, ID, and column
- **Flexible Schema**: Frontend specifies table structure
- **Multiple Value Types**: Text, Integer, Float, Boolean, Blob
- **Batch Operations**: Atomic multi-value writes
- **Query Support**: Custom SQL queries
- **Table Management**: Create, drop, list tables

## Setup

1. Install Rust and dependencies:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

1. Build the project:

```bash
cargo build --release
```

1. Run the server:

```bash
cargo run
```

1. Test with client:

```bash
cargo run --bin client_example
```

## Usage Examples

### Write a single value:

```rust
WriteValueRequest {
    table_name: "users",
    id_column: "id", 
    id_value: IntValue(1),
    column_name: "name",
    column_value: TextValue("John"),
    create_if_missing: true
}
```

### Read entire row:

```rust
ReadRowRequest {
    table_name: "users",
    id_column: "id",
    id_value: IntValue(1),
    columns: vec![] // empty = all columns
}
```

The server runs on `[::1]:50051` by default.
